import numpy as np
import pandas as pd

# Assuming your class AssortativeMatingSimulation and utility functions are in SimulationFunctions.py
# If utility functions like is_even, cor2cov are also needed directly in this test script,
# they would be imported too. For this example, we primarily need the class.
from SimulationFunctions import AssortativeMatingSimulation

#def run_test_simulation():
"""
Sets up parameters and runs a test instance of the AssortativeMatingSimulation.
"""
print("--- Setting up Test Simulation Parameters ---")

# --- Define all your input parameters as Python objects ---
num_generations_val = 15   # Keep small for a quick test
pop_size_val = 2e4         # Population size

# Parameters for prepare_CV (will be called internally by the class)
n_CV_val = 500              # Number of Causal Variants
rg_effects_val = 0      # Genetic correlation between trait effects (alphas)
maf_min_val = 0.30
maf_max_val = 0.49
maf_dist_val = "uniform"   # MAF distribution

# Mating type for the simulation
mating_type_val = "phenotypic" # Options: "phenotypic", "social", "genotypic"

# Define k2_matrix: Expected variance of AO1,AO2 (raw genetic values from SNPs)
# If prepare_CV standardizes total genetic variance to ~1 per trait (when rg_effects=0),
# then k2_matrix reflects this.
k2_val = np.array([[1.0, rg_effects_val], [rg_effects_val, 1.0]]) 

# Path coefficients and environmental covariance matrices

# d_mat scales AO (raw) to AO_std (Y-scaled contribution).
# Var(AO_std1) = d_mat[0,0]^2 * Var(AO1). If Var(AO1) is k2_val[0,0] (e.g., 1.0)
# and target Var(AO_std1) is 0.3, then d_mat[0,0] = sqrt(0.3 / 1.0)
target_VAO_std_diag = np.array([0.16, .36])
d_mat_diag_elements = np.sqrt(target_VAO_std_diag)
d_mat_val = np.diag(d_mat_diag_elements)

# a_mat scales AL (raw) to AL_std (Y-scaled contribution).
# Assume Var(AL) is similar to Var(AO) if generated by similar mechanism (though not explicitly defined by prepare_CV).
# For simplicity, let's assume k2_val applies to AL as well for scaling.
target_VAL_std_diag = np.array([.34, .49])
a_mat_diag_elements = np.sqrt(target_VAL_std_diag)
a_mat_val = np.diag(a_mat_diag_elements)

# f_mat scales parental Y to F_from_Y (Y-scaled parental Y contribution to offspring F)
# s_mat scales parental (F+E) to F_from_Social (Y-scaled parental social env. to offspring F)
# Let total target VF (variance of offspring F1,F2) = [0.3, 0.3]
# Split this between f_mat and s_mat pathways. E.g., f_mat contributes 0.15, s_mat contributes 0.15

covy_val = np.array([[1.0, 0], [0, 1.0]]) # Expected Phenotypic var/cov at t0

fmat_val = np.array([[0,0],[0,0]])
    
# s_mat: For the new social transmission path (Parental F+E -> Offspring F)
# This requires assumptions about Var(Parental F+E).
# For simplicity, let's set s_mat to achieve a portion of F variance. This is a rough example.
# The actual variance contribution from s_mat would depend on the variance of (Parental F+E).
# target_VF_from_Social_diag = np.array([0.15, 0.15])
# Assuming Var(Parental F1+E1) is roughly 0.5 (example). Var_contrib_per_parent = 0.15/2 = 0.075
# s_mat_diag_element = sqrt( (target_VF_from_Social_diag_per_parent) / Var(Parental_F+E) )
s_mat_val = np.array([[0,0],[0,0]]) 
# If s_mat is not desired for a test, pass s_mat=None or np.zeros((2,2))

# cove_mat is Var(E1, E2) where E1, E2 are Y-scaled unique env for offspring. Target VE_y = [0.2, 0.2]
# Let cov(E1,E2) = 0.05
cove_val = np.array([[0.5, 0], [0, 0.15]])

# Assortative mating correlation parameters (mu matrix in R script)
# This is a list of 2x2 matrices, one for each generation of parents.
am_corr_example = np.array([[.4, .1], [.05, 0.3]]) 
am_list_generations = [am_corr_example] * num_generations_val 
output_summary_filename_val = "Scripts/01-Simulation/onlyAM.txt"

print("--- Initializing AssortativeMatingSimulation Instance ---")
sim_instance = AssortativeMatingSimulation(
    # CV generation parameters
    n_CV=n_CV_val, 
    rg_effects=rg_effects_val, 
    maf_min=maf_min_val, 
    maf_max=maf_max_val,
    maf_dist=maf_dist_val,
    # Core simulation parameters
    num_generations=num_generations_val,
    pop_size=pop_size_val,
    mating_type=mating_type_val,
    avoid_inbreeding=True,
    save_each_gen=True, # Set True to inspect history if needed
    save_covs=True,   # Set True to inspect covariances if needed
    seed=12345,       # For reproducibility
    # Model matrices
    cove_mat=cove_val,
    f_mat=fmat_val,
    s_mat=s_mat_val, # Pass the social transmission matrix
    a_mat=a_mat_val,
    d_mat=d_mat_val,
    am_list=am_list_generations,
    covy_mat=covy_val,
    k2_matrix=k2_val,
    output_summary_filename=output_summary_filename_val,
    summary_file_scope="all"
)

print("--- Running Simulation ---")
results = sim_instance.run_simulation()

print("\n--- Simulation Finished ---")

# if results and results.get('SUMMARY.RES'):
#     summary_df = pd.DataFrame(results['SUMMARY.RES'])
#     pd.set_option('display.max_columns', None)
#     pd.set_option('display.width', 200) # Adjust width for your console
    
#     print("\nSimulation Summary Results (Selected Columns):")
#     cols_to_print = ['GEN', 'POPSIZE', 'VAO', 'VAL', 'VF', 'VE', 'VP', 'h2', 'h2.obs']
#     existing_cols_to_print = [col for col in cols_to_print if col in summary_df.columns]
#     print(summary_df[existing_cols_to_print])

    # You can also access other parts of the results dictionary:
    # print("\nFinal Phenotype Data (first 5 individuals):")
    # if results['PHEN'] is not None and not results['PHEN'].empty:
    #     print(results['PHEN'].head())
    
    # print("\nXO matrix for the last generation (shape):")
    # if results['XO'] is not None:
    #     print(results['XO'].shape)

    # if sim_instance.save_each_gen and results['HISTORY'] and results['HISTORY']['PHEN']:
    #     print(f"\nNumber of generations in PHEN history: {len(results['HISTORY']['PHEN'])}")
    #     print(f"Phenotypes for Gen 0 (first 3): \n{results['HISTORY']['PHEN'][0].head(3)}")
    #     if len(results['HISTORY']['PHEN']) > 1:
    #         print(f"Phenotypes for Gen 1 (first 3): \n{results['HISTORY']['PHEN'][1].head(3)}")


# if __name__ == '__main__':
#     run_test_simulation()

# result1 = results['SUMMARY.RES']
# result1[1]
from save_simulation_data import *

save_simulation_results(results=results,
                        output_folder="Data/test1/onlyAM",
                        scope="all")